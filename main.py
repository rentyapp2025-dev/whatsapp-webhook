import os
import hmac
import hashlib
import json
import re
from typing import Optional, Any, Dict, List
import logging
from datetime import datetime
import asyncio
import random

from fastapi import FastAPI, Request, Response, HTTPException, Query
from fastapi.responses import PlainTextResponse
import httpx

# ==================== CONFIGURACI√ìN Y LOGGING AVANZADO ====================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | ü§ñ BOT | %(message)s',
    datefmt='%H:%M:%S'
)

# Variables de entorno con validaci√≥n robusta
VERIFY_TOKEN = os.getenv("VERIFY_TOKEN", "")
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN", "")
PHONE_NUMBER_ID = os.getenv("PHONE_NUMBER_ID", "")
APP_SECRET = os.getenv("APP_SECRET", "").encode("utf-8") if os.getenv("APP_SECRET") else b""
GRAPH_API_VERSION = os.getenv("GRAPH_API_VERSION", "v20.0")
GRAPH_BASE = f"https://graph.facebook.com/{GRAPH_API_VERSION}"

# Validaci√≥n cr√≠tica de variables de entorno
if not all([VERIFY_TOKEN, WHATSAPP_TOKEN, PHONE_NUMBER_ID]):
    logging.error("üí• CONFIGURACI√ìN CR√çTICA FALTANTE | Revisa tus variables de entorno")
    logging.info("üìã Variables requeridas: VERIFY_TOKEN, WHATSAPP_TOKEN, PHONE_NUMBER_ID")

app = FastAPI(
    title="üè¶ Per Capital WhatsApp Bot",
    description="Bot de soporte inteligente con experiencia premium",
    version="3.0.0"
)

# ==================== BASE DE CONOCIMIENTO PREMIUM ====================
QA_CATEGORIZED = {
    "üí∞ Inversiones": {
        "üî∞ ¬øC√≥mo puedo empezar a invertir?": "Para comenzar tu journey de inversi√≥n:\n\n‚úÖ **Paso 1:** Reg√≠strate y completa tu verificaci√≥n en la app\n‚úÖ **Paso 2:** Ve a 'Negociaci√≥n' ‚Üí 'Suscripci√≥n'\n‚úÖ **Paso 3:** Ingresa el monto deseado\n‚úÖ **Paso 4:** Selecciona tu m√©todo de pago preferido\n‚úÖ **Paso 5:** Sube tu comprobante\n\n‚è∞ *Tu inversi√≥n se hace efectiva al cierre del d√≠a o siguiente d√≠a h√°bil*",
       
        "üéØ ¬øQu√© es el Fondo Mutual Abierto?": "El **Fondo Mutual Abierto** es tu puerta de entrada al mercado financiero üö™\n\nüíº Es como una *canasta inteligente* que contiene:\n‚Ä¢ Acciones diversificadas\n‚Ä¢ Bonos de renta fija\n‚Ä¢ Instrumentos financieros premium\n\nüîç **¬°Lo mejor?** Puedes ver exactamente d√≥nde est√° tu dinero trabajando dentro de la app",
       
        "üåü ¬øEn qu√© puedo invertir?": "**¬°Excelente pregunta!** üéâ\n\nActualmente ofrecemos:\n\nüíé **Fondo Mutual Abierto** con portafolio diversificado:\n‚Ä¢ üáªüá™ **En Bol√≠vares:** Acciones que cotizan en BVC\n‚Ä¢ üíµ **En D√≥lares:** Papeles comerciales y renta fija\n\nüìä Todo estrat√©gicamente balanceado para optimizar tu rentabilidad",
       
        "üìä ¬øQu√© son las Unidades de Inversi√≥n (UI)?": "Las **Unidades de Inversi√≥n (UI)** son tu *participaci√≥n inteligente* en el fondo üß©\n\nüî¢ **Pi√©nsalo as√≠:**\n‚Ä¢ Cada UI = Una porci√≥n del pastel completo\n‚Ä¢ Su valor fluct√∫a seg√∫n el rendimiento\n‚Ä¢ Representan tu % del patrimonio total\n\nüìà Es la forma m√°s eficiente de participar en mercados diversificados",
       
        "üíπ ¬øQu√© es el Valor de Unidad de Inversi√≥n (VUI)?": "El **VUI** es el *precio actual* de cada unidad que posees üí∞\n\nüìä **Caracter√≠sticas clave:**\n‚Ä¢ Se actualiza diariamente\n‚Ä¢ Refleja el valor de mercado real\n‚Ä¢ Base para calcular tu inversi√≥n total\n‚Ä¢ Cambia seg√∫n performance del mercado\n\n‚ö° *¬°Es el pulso de tu inversi√≥n en tiempo real!*",
       
        "üìâ ¬øPor qu√© baja mi rendimiento?": "¬°Tranquilo! üòå Los mercados son como monta√±as rusas:\n\nüìä **Tu inversi√≥n refleja:**\n‚Ä¢ Valor total de activos del fondo\n‚Ä¢ Condiciones del mercado\n‚Ä¢ Performance de inversiones subyacentes\n\n‚è∞ **Recuerda:** Los Fondos Mutuales son para *horizontes largos*\nüéØ **Tip:** La paciencia es tu mejor aliada en inversiones",
       
        "üéÆ ¬øQu√© hago despu√©s de suscribir?": "¬°Perfecto! Ya est√°s en el juego üèÜ\n\n**Tu pr√≥ximo nivel:**\n‚Ä¢ üì± Monitorea desde la app\n‚Ä¢ üëÄ Observa tu portafolio en detalle\n‚Ä¢ üí§ Nosotros gestionamos activamente\n‚Ä¢ üìä Revisa performance cuando gustes\n\n*¬°T√∫ rel√°jate, nosotros trabajamos tu dinero!* üòé",
       
        "üí∏ ¬øCu√°nto cuestan las comisiones?": "**Estructura transparente de fees:**\n\nüí≥ **Suscripci√≥n:** 3% (una sola vez)\nüîÑ **Administraci√≥n:** 5% anualizado\n\nüí° **¬°Sin sorpresas!** Todo claro desde el inicio",
       
        "üíµ ¬øDesde cu√°nto puedo invertir?": "**¬°Democratizamos las inversiones!** üåü\n\nüí∞ **M√≠nimo:** Solo 1 Bol√≠var\nüöÄ **M√°ximo:** ¬°El cielo es el l√≠mite!\n\n*Porque creemos que todos merecen crecer financieramente* üí™",
       
        "‚è∞ ¬øCu√°ndo veo ganancias?": "**¬°Excelente mindset de largo plazo!** üéØ\n\nüìÖ **Para horizontes cortos:** No recomendamos FMA\nüìà **Para horizontes largos:** ¬°Aqu√≠ brillamos!\n‚è≥ **Paciencia = Rentabilidad**\n\nüèÜ *Los grandes inversionistas piensan en a√±os, no en d√≠as*",
       
        "üìà ¬øC√≥mo compro acciones individuales?": "**¬°Coming soon!** üöÄ\n\nüîú **Pr√≥ximamente:** Compra/venta directa de acciones\nüíé **Mientras tanto:** FMA con portafolio de acciones seleccionadas\n\n*¬°Mantente conectado para las novedades!* üì±"
    },
   
    "üí≥ Retiros y Transacciones": {
        "üí∞ ¬øC√≥mo hago un retiro?": "**¬°Proceso s√∫per simple!** ‚ö°\n\n**Pasos para tu rescate:**\n1Ô∏è‚É£ Selecciona **'Rescate'**\n2Ô∏è‚É£ Ingresa unidades a rescatar\n3Ô∏è‚É£ Haz clic en **'Calcular'**\n4Ô∏è‚É£ Confirma con **'Rescatar'**\n5Ô∏è‚É£ Sigue las instrucciones finales\n\n*¬°Tu dinero, tu decisi√≥n, tu control!* üéÆ",
       
        "ü§î Nunca he rescatado antes": "**¬°Sin problema!** üòä\n\n**Si recibiste un email sobre rescate:**\n‚Ä¢ üìß Ign√≥ralo si no has rescatado\n‚Ä¢ üì± Mejor ingresa a la app\n‚Ä¢ ‚úÖ Valida tus fondos directamente\n\n*¬°Tu app es tu fuente de verdad!* üíØ",
       
        "üí∏ ¬øCu√°nto puedo retirar?": "**Flexibilidad total:** üåü\n\n**M√≠nimo:** 1 Unidad de Inversi√≥n\n**M√°ximo:** Todas tus unidades disponibles\n\n*¬°T√∫ decides cu√°nto y cu√°ndo!* üéØ",
       
        "üîÑ Proceso de rescate paso a paso": "**¬°Tu gu√≠a completa!** üìã\n\nüéØ **Flujo optimizado:**\n‚Ä¢ **Rescate** ‚Üí **Unidades** ‚Üí **Calcular** ‚Üí **Rescatar** ‚Üí **¬°Listo!**\n\n‚ö° Simple, r√°pido y seguro"
    },
   
    "üîê Problemas con la Cuenta": {
        "‚è≥ Mi usuario est√° en revisi√≥n": "**¬°Te ayudamos inmediatamente!** üöÄ\n\nüìã **Para acelerar tu aprobaci√≥n:**\n‚Ä¢ Env√≠anos tu n√∫mero de c√©dula\n‚Ä¢ Verificaremos documentaci√≥n\n‚Ä¢ Activaremos tu cuenta\n\n*¬°Estamos aqu√≠ para ti!* üí™",
       
        "üîë ¬øC√≥mo recupero mi clave?": "**¬°Recovery mode activado!** üõ†Ô∏è\n\n**Proceso s√∫per seguro:**\n1Ô∏è‚É£ Selecciona **'Recuperar'**\n2Ô∏è‚É£ Recibir√°s clave temporal\n3Ô∏è‚É£ √ösala para ingresar\n4Ô∏è‚É£ Sistema pedir√° nueva clave\n5Ô∏è‚É£ Confirma tu nueva password\n\n*¬°Back in business!* ‚ú®",
       
        "‚è∞ ¬øPor qu√© tardan en aprobar?": "**¬°Gracias por tu paciencia!** üôè\n\nüìä **Situaci√≥n actual:**\n‚Ä¢ Alto tr√°fico de registros\n‚Ä¢ Trabajamos 24/7 en aprobaciones\n‚Ä¢ Tu experiencia es nuestra prioridad\n\nüìé **Acelera tu proceso:** Env√≠a c√©dula escaneada",
       
        "‚úÖ ¬øYa estoy aprobado?": "**¬°Bienvenido oficialmente!** üéâ\n\n‚ú® **Tu cuenta est√° ACTIVA**\n‚ö†Ô∏è **Importante:** Modificaciones requieren nueva revisi√≥n\n‚è∞ **Suscripciones antes 12PM:** Efectivas al cierre (5-6 PM)\n\n*¬°A invertir se ha dicho!* üöÄ",
       
        "üì± No recibo SMS de verificaci√≥n": "**¬°Solucionemos esto!** üîß\n\nüîÑ **Plan de acci√≥n:**\n1Ô∏è‚É£ Intenta desde otra ubicaci√≥n\n2Ô∏è‚É£ Espera unas horas\n3Ô∏è‚É£ Prueba ma√±ana\n4Ô∏è‚É£ Como √∫ltimo recurso: otro n√∫mero\n\n*¬°No te rendiremos hasta que funcione!* üí™"
    },
   
    "üåé Otros Tipos de Inversi√≥n": {
        "üíµ ¬øC√≥mo invierto en d√≥lares?": "**¬°Diversifica en USD!** üá∫üá∏\n\nüíé **Papel Comercial disponible:**\n‚Ä¢ Instrumentos de deuda corto plazo\n‚Ä¢ Menos de 1 a√±o de duraci√≥n\n‚Ä¢ Emitidos por empresas s√≥lidas\n‚Ä¢ En el mercado de valores\n\n*¬°Tu portafolio internacional te espera!* üåü",
       
        "üìÑ ¬øC√≥mo invierto en papel comercial?": "**¬°Proceso premium!** ‚≠ê\n\nüìã **Requisitos:**\n‚Ä¢ ‚úÖ Registro Per Capital\n‚Ä¢ ‚úÖ Registro Caja Venezolana\n‚Ä¢ ‚úÖ C√©dula + RIF + Constancia trabajo\n‚Ä¢ ‚úÖ Per Capital como depositante\n\nüîó Te enviaremos el link de Caja Venezolana",
       
        "üè¶ ¬øYa me registr√© en Caja Venezolana?": "**¬°No te preocupes!** üòå\n\n**Para FMA:** No necesitas Caja Venezolana a√∫n\n**Para acciones:** Pr√≥ximamente ser√° requerido\n**Mientras tanto:** ¬°Disfruta del FMA!\n\n*¬°Un paso a la vez hacia el √©xito!* üéØ",
       
        "üìä Info detallada de inversiones": "**¬°Tu centro de informaci√≥n!** üìö\n\n**FMA incluye:**\n‚Ä¢ üèõÔ∏è Acciones BVC Caracas\n‚Ä¢ üìÑ Papeles comerciales\n‚Ä¢ üéØ Portafolio diversificado\n\nüì± **Todo visible en tu app con lujo de detalles**"
    }
}

# Estado global mejorado para conversaciones
conversation_state: Dict[str, Dict[str, Any]] = {}

# ==================== FUNCIONES PREMIUM DE EXPERIENCIA ====================

def get_welcome_emoji() -> str:
    """Obtiene un emoji de bienvenida aleatorio para m√°s dinamismo"""
    emojis = ["üéâ", "‚ú®", "üåü", "üí´", "üéä", "üöÄ", "üíé", "‚≠ê"]
    return random.choice(emojis)

def get_time_greeting() -> str:
    """Saludo contextual seg√∫n la hora"""
    hour = datetime.now().hour
    if 5 <= hour < 12:
        return "¬°Buenos d√≠as! ‚òÄÔ∏è"
    elif 12 <= hour < 18:
        return "¬°Buenas tardes! üå§Ô∏è"
    else:
        return "¬°Buenas noches! üåô"

def get_menu_by_category_index(index: int) -> Optional[Dict[str, str]]:
    """Obtiene submen√∫ con mejor UX"""
    categories = list(QA_CATEGORIZED.keys())
    if 1 <= index <= len(categories):
        category_name = categories[index - 1]
        return {
            "title": category_name,
            "questions": QA_CATEGORIZED[category_name]
        }
    return None

def get_answer_by_full_index(category_index: int, question_index: int) -> str:
    """Respuesta con validaci√≥n mejorada"""
    category_menu = get_menu_by_category_index(category_index)
    if not category_menu:
        return "üö´ **Ups!** Esa categor√≠a no existe.\n\nüì± *Consejo:* Usa los n√∫meros del men√∫ principal (1-4)"
   
    questions = list(category_menu["questions"].keys())
    if 1 <= question_index <= len(questions):
        question = questions[question_index - 1]
        return category_menu["questions"][question]
   
    return f"‚ùì **Pregunta no encontrada**\n\nPor favor selecciona entre las opciones 1-{len(questions)} del submen√∫ actual."

def is_back_command(text: str) -> bool:
    """Comandos de navegaci√≥n expandidos"""
    back_keywords = [
        "volver", "menu", "men√∫", "principal", "inicio", "back", "home",
        "atras", "atr√°s", "salir", "regresar", "0", "menu principal"
    ]
    return text.strip().lower() in back_keywords

# ==================== MENSAJES PREMIUM CON DISE√ëO AVANZADO ====================

async def send_welcome_experience(to_msisdn: str) -> Dict[str, Any]:
    """Experiencia de bienvenida ultra premium"""
    greeting = get_time_greeting()
    emoji = get_welcome_emoji()
   
    payload = {
        "messaging_product": "whatsapp",
        "to": to_msisdn,
        "type": "interactive",
        "interactive": {
            "type": "button",
            "header": {
                "type": "text",
                "text": f"üè¶ Per Capital | Tu Futuro Financiero"
            },
            "body": {
                "text": f"{greeting} {emoji}\n\n**¬°Bienvenido a Per Capital!**\n\nSoy tu asistente financiero inteligente, dise√±ado para brindarte la mejor experiencia de inversi√≥n.\n\nüéØ **¬øC√≥mo quieres continuar?**\n\n‚Ä¢ ü§ñ **Asistente Virtual:** Respuestas instant√°neas 24/7\n‚Ä¢ üë®‚Äçüíº **Especialista Humano:** Asesor√≠a personalizada\n\n*Selecciona tu preferencia y comencemos tu journey financiero* ‚ú®"
            },
            "footer": {
                "text": "Per Capital ‚Ä¢ Invierte con confianza"
            },
            "action": {
                "buttons": [
                    {
                        "type": "reply",
                        "reply": {
                            "id": "bot_premium",
                            "title": "ü§ñ Asistente Virtual"
                        }
                    },
                    {
                        "type": "reply",
                        "reply": {
                            "id": "human_vip",
                            "title": "üë®‚Äçüíº Especialista VIP"
                        }
                    }
                ]
            }
        }
    }
    return await _post_messages(payload)

async def send_main_menu_premium(to_msisdn: str) -> Dict[str, Any]:
    """Men√∫ principal con dise√±o premium"""
    # Limpiar estado
    if to_msisdn in conversation_state:
        del conversation_state[to_msisdn]
   
    # Crear men√∫ visualmente impactante
    menu_text = "üéØ **CENTRO DE INFORMACI√ìN FINANCIERA**\n"
    menu_text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
   
    categories_emojis = ["üí∞", "üí≥", "üîê", "üåé"]
    categories_list = list(QA_CATEGORIZED.keys())
   
    for i, category in enumerate(categories_list, 1):
        clean_name = category.split(' ', 1)[1] if ' ' in category else category
        menu_text += f"**{i}.** {category}\n"
        menu_text += f"     *{get_category_description(i)}*\n\n"
   
    menu_text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    menu_text += "üí° **NAVEGACI√ìN F√ÅCIL:**\n"
    menu_text += "‚Ä¢ Env√≠a el **n√∫mero** de tu inter√©s (ej: `1`)\n"
    menu_text += "‚Ä¢ Escribe `volver` para regresar aqu√≠\n"
    menu_text += "‚Ä¢ Escribe `menu` en cualquier momento\n\n"
    menu_text += "*¬°Tu √©xito financiero comienza con una buena decisi√≥n!* üöÄ"
   
    return await send_text(to_msisdn, menu_text)

def get_category_description(category_num: int) -> str:
    """Descripciones atractivas para cada categor√≠a"""
    descriptions = {
        1: "Todo sobre inversiones y fondos mutuales",
        2: "Retiros, rescates y transacciones",
        3: "Soporte t√©cnico y problemas de cuenta",
        4: "Inversiones internacionales y productos premium"
    }
    return descriptions.get(category_num, "Informaci√≥n especializada")

async def send_subcategory_premium(to_msisdn: str, category_index: int) -> Dict[str, Any]:
    """Submen√∫ con experiencia premium"""
    category_menu = get_menu_by_category_index(category_index)
    if not category_menu:
        await send_text(to_msisdn, "‚ùå **Error de navegaci√≥n**\n\nEsa categor√≠a no est√° disponible. Regresemos al inicio.")
        await send_main_menu_premium(to_msisdn)
        return {}

    # Guardar estado avanzado
    conversation_state[to_msisdn] = {
        "category": str(category_index),
        "timestamp": datetime.now().isoformat(),
        "questions_viewed": []
    }

    # Crear submen√∫ impactante
    menu_text = f"üìÇ **{category_menu['title'].upper()}**\n"
    menu_text += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
    menu_text += "üéØ **Selecciona tu consulta:**\n\n"
   
    questions = list(category_menu["questions"].keys())
    for i, question in enumerate(questions, 1):
        # Limpiar formato de pregunta
        clean_question = re.sub(r'^[üéØüí∞üìäüí°üî∞‚≠êüíéüåüüìàüíπüìâüéÆüí∏üíµ‚è∞üí≥ü§îüí∏üîÑüîê‚è≥üîë‚è∞‚úÖüì±üåéüíµüìÑüè¶üìä]?\s*', '', question)
        clean_question = re.sub(r'^\d+\.\s*', '', clean_question)
       
        # Emoji din√°mico por pregunta
        question_emoji = get_question_emoji(i)
        menu_text += f"**{i}.** {question_emoji} {clean_question}\n"
   
    menu_text += "\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    menu_text += "üß≠ **NAVEGACI√ìN:**\n"
    menu_text += f"‚Ä¢ N√∫mero de pregunta (1-{len(questions)})\n"
    menu_text += "‚Ä¢ `volver` ‚Üí Men√∫ principal\n"
    menu_text += "‚Ä¢ `menu` ‚Üí Inicio\n\n"
    menu_text += "*¬°Estamos aqu√≠ para resolver todas tus dudas!* ‚ú®"
   
    return await send_text(to_msisdn, menu_text)

def get_question_emoji(question_num: int) -> str:
    """Emoji din√°mico para cada pregunta"""
    emojis = ["üéØ", "üí°", "‚≠ê", "üöÄ", "üíé", "üî•", "‚ö°", "üåü", "üí´", "‚ú®", "üéä", "üèÜ"]
    return emojis[question_num % len(emojis)]

# ==================== PROCESAMIENTO DE MENSAJES AVANZADO ====================

async def process_text_message_premium(from_msisdn: str, message_text: str) -> None:
    """Procesamiento de texto con UX premium"""
    text_clean = message_text.strip()
   
    # Log con estilo
    logging.info(f"üí¨ Usuario {from_msisdn[-4:]}**** ‚Üí '{text_clean[:30]}{'...' if len(text_clean) > 30 else ''}'")
   
    # Comando de regreso
    if is_back_command(text_clean):
        await send_text(from_msisdn, "üîÑ **Regresando al men√∫ principal...**")
        await asyncio.sleep(0.5)  # Micro-pausa para UX
        await send_main_menu_premium(from_msisdn)
        return
   
    # Procesamiento num√©rico inteligente
    try:
        choice = int(text_clean)
        user_state = conversation_state.get(from_msisdn, {})
        current_category = user_state.get("category")
       
        if current_category is None:
            # Selecci√≥n de categor√≠a
            if 1 <= choice <= len(QA_CATEGORIZED):
                await send_text(from_msisdn, f"üìÇ **Cargando informaci√≥n especializada...** ‚è≥")
                await asyncio.sleep(0.3)
                await send_subcategory_premium(from_msisdn, choice)
            else:
                await send_text(from_msisdn,
                    f"üö´ **Opci√≥n no v√°lida**\n\n"
                    f"Por favor selecciona entre 1-{len(QA_CATEGORIZED)}.\n\n"
                    f"*¬øPrefieres ver el men√∫ nuevamente?* üìã")
                await send_main_menu_premium(from_msisdn)
        else:
            # Respuesta a pregunta
            category_index = int(current_category)
           
            # Actualizar estado
            user_state.setdefault("questions_viewed", []).append(choice)
           
            # Obtener respuesta
            response_text = get_answer_by_full_index(category_index, choice)
           
            # Env√≠o con estilo
            await send_text(from_msisdn, "üí≠ **Consultando nuestra base de conocimiento...** ‚è≥")
            await asyncio.sleep(0.5)
           
            formatted_response = f"‚úÖ **RESPUESTA ESPECIALIZADA**\n"
            formatted_response += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            formatted_response += f"{response_text}\n\n"
            formatted_response += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            formatted_response += "üí¨ **¬øTe fue √∫til esta informaci√≥n?**\n\n"
            formatted_response += "üîÑ *En un momento ver√°s el men√∫ principal para nuevas consultas*"
           
            await send_text(from_msisdn, formatted_response)
           
            # Pausa y regreso al men√∫ principal
            await asyncio.sleep(2)
            await send_text(from_msisdn, "üìã **¬øAlguna otra consulta?** Aqu√≠ tienes el men√∫ completo:")
            await send_main_menu_premium(from_msisdn)
           
    except (ValueError, IndexError):
        # Input no num√©rico
        user_state = conversation_state.get(from_msisdn, {})
        current_category = user_state.get("category")
       
        if current_category is not None:
            await send_text(from_msisdn,
                "üî¢ **Formato requerido: Solo n√∫meros**\n\n"
                "Por favor env√≠a el n√∫mero de la pregunta que te interesa.\n\n"
                "*Ejemplo: env√≠a `1` para la primera opci√≥n* üí°")
            await send_subcategory_premium(from_msisdn, int(current_category))
        else:
            # Trigger men√∫ inicial
            await send_welcome_experience(from_msisdn)

async def process_interactive_premium(from_msisdn: str, interactive_data: Dict[str, Any]) -> None:
    """Procesamiento de botones con experiencia premium"""
    if interactive_data.get("type") == "button_reply":
        button_reply = interactive_data.get("button_reply", {})
        button_id = button_reply.get("id")
       
        logging.info(f"üîò Usuario {from_msisdn[-4:]}**** presion√≥ ‚Üí {button_id}")
       
        if button_id == "bot_premium":
            await send_text(from_msisdn,
                "ü§ñ **ASISTENTE VIRTUAL ACTIVADO** ‚ú®\n\n"
                "¬°Perfecto! Has elegido la experiencia m√°s r√°pida y eficiente.\n\n"
                "üéØ **Ventajas del Asistente Virtual:**\n"
                "‚Ä¢ ‚ö° Respuestas instant√°neas 24/7\n"
                "‚Ä¢ üìö Acceso a toda nuestra base de conocimiento\n"
                "‚Ä¢ üé® Navegaci√≥n intuitiva y f√°cil\n"
                "‚Ä¢ üîÑ Disponible cuando lo necesites\n\n"
                "*¬°Comencemos con tu consulta!* üöÄ")
            await asyncio.sleep(1)
            await send_main_menu_premium(from_msisdn)
           
        elif button_id == "human_vip":
            await send_text(from_msisdn,
                "üë®‚Äçüíº **ESPECIALISTA VIP CONTACTADO** üåü\n\n"
                "¬°Excelente elecci√≥n! Has optado por nuestro servicio premium de atenci√≥n personalizada.\n\n"
                "üéØ **¬øQu√© sigue ahora?**\n"
                "‚Ä¢ üìû Un especialista certificado te contactar√° pronto\n"
                "‚Ä¢ üíº Recibir√°s atenci√≥n completamente personalizada\n"
                "‚Ä¢ üïê Horario de contacto: Lunes a Viernes 8AM-6PM\n"
                "‚Ä¢ üì± Para urgencias, tambi√©n puedes llamarnos directamente\n\n"
                "üìã **Informaci√≥n importante:**\n"
                "‚Ä¢ Tu consulta ha sido registrada con prioridad VIP\n"
                "‚Ä¢ Recibir√°s seguimiento especializado\n"
                "‚Ä¢ Este chat autom√°tico ha finalizado\n\n"
                "**¬°Gracias por confiar en Per Capital!** üèÜ\n"
                "*Tu √©xito financiero es nuestra misi√≥n* ‚ú®")
           
            # Limpiar estado
            if from_msisdn in conversation_state:
                del conversation_state[from_msisdn]

# ==================== FUNCIONES DE ENV√çO OPTIMIZADAS ====================

def verify_signature(signature: Optional[str], body: bytes) -> bool:
    """Verificaci√≥n de firma con logging mejorado"""
    if not APP_SECRET:
        logging.warning("‚ö†Ô∏è APP_SECRET no configurada - Verificaci√≥n deshabilitada")
        return True
   
    if not signature or not signature.startswith("sha256="):
        logging.error("üö´ Firma de solicitud inv√°lida o ausente")
        return False
   
    their_signature = signature.split("sha256=")[-1].strip()
    mac = hmac.new(APP_SECRET, msg=body, digestmod=hashlib.sha256)
    our_signature = mac.hexdigest()
   
    is_valid = hmac.compare_digest(our_signature, their_signature)
    if not is_valid:
        logging.error("‚ùå Firma no coincide - Posible intento de acceso no autorizado")
    return is_valid

async def _post_messages(payload: Dict[str, Any]) -> Dict[str, Any]:
    """Env√≠o de mensajes con retry autom√°tico y logging premium"""
    url = f"{GRAPH_BASE}/{PHONE_NUMBER_ID}/messages"
    headers = {
        "Authorization": f"Bearer {WHATSAPP_TOKEN}",
        "Content-Type": "application/json"
    }
   
    max_retries = 3
    for attempt in range(max_retries):
        try:
            async with httpx.AsyncClient(timeout=30) as client:
                response = await client.post(url, headers=headers, json=payload)
                response.raise_for_status()
               
                recipient = payload.get('to', 'Unknown')[-4:]
                logging.info(f"‚úÖ Mensaje enviado exitosamente ‚Üí Usuario ****{recipient}")
                return response.json()
               
        except httpx.HTTPStatusError as e:
            logging.error(f"‚ùå Error HTTP {e.response.status_code} en intento {attempt + 1}/{max_retries}")
            if attempt == max_retries - 1:
                logging.error(f"üí• Fallo definitivo enviando mensaje: {e.response.text}")
                raise HTTPException(status_code=500, detail=f"Error sending message after {max_retries} attempts")
            await asyncio.sleep(2 ** attempt)  # Backoff exponencial
           
        except Exception as e:
            logging.error(f"üí• Error inesperado en intento {attempt + 1}: {e}")
            if attempt == max_retries - 1:
                raise HTTPException(status_code=500, detail="Critical error sending message")
            await asyncio.sleep(1)

async def send_text(to_msisdn: str, text: str) -> Dict[str, Any]:
    """Env√≠o de texto con formato optimizado"""
    payload = {
        "messaging_product": "whatsapp",
        "to": to_msisdn,
        "type": "text",
        "text": {
            "body": text,
            "preview_url": False
        }
    }
    return await _post_messages(payload)

# ==================== ENDPOINTS PREMIUM ====================

@app.get("/webhook")
async def verify_webhook(
    hub_mode: str | None = Query(None, alias="hub.mode"),
    hub_challenge: str | None = Query(None, alias="hub.challenge"),
    hub_verify_token: str | None = Query(None, alias="hub.verify_token"),
):
    """Verificaci√≥n de webhook con logging premium"""
    logging.info(f"üîç Verificaci√≥n webhook ‚Üí Mode: {hub_mode} | Token: {'‚úÖ' if hub_verify_token == VERIFY_TOKEN else '‚ùå'}")
   
    if hub_mode == "subscribe" and hub_verify_token == VERIFY_TOKEN:
        logging.info("‚úÖ Webhook verificado exitosamente - Bot listo para recibir mensajes")
        return PlainTextResponse(content=hub_challenge or "", status_code=200)
   
    logging.error("üö´ Verificaci√≥n fallida - Token inv√°lido o modo incorrecto")
    raise HTTPException(status_code=403, detail="Verification failed")

@app.post("/webhook")
async def receive_webhook_premium(request: Request):
    """Webhook principal con procesamiento premium y manejo avanzado de errores"""
    start_time = datetime.now()
   
    try:
        # Leer y verificar solicitud
        body_bytes = await request.body()
        signature = request.headers.get("X-Hub-Signature-256")
       
        if not verify_signature(signature, body_bytes):
            logging.error("üö´ Acceso denegado - Firma inv√°lida")
            raise HTTPException(status_code=403, detail="Invalid signature")
       
        # Parse JSON con validaci√≥n
        try:
            data = await request.json()
        except json.JSONDecodeError:
            logging.error("üí• JSON malformado recibido")
            raise HTTPException(status_code=400, detail="Invalid JSON format")
       
        # Log del webhook recibido (sin datos sensibles)
        logging.info(f"üì® Webhook recibido ‚Üí Entries: {len(data.get('entry', []))}")
       
        # Validar estructura b√°sica
        if data.get("object") != "whatsapp_business_account":
            logging.info("‚ÑπÔ∏è Webhook ignorado - No es de WhatsApp Business")
            return Response(status_code=200)
       
        # Procesar cada entrada
        messages_processed = 0
        for entry in data.get("entry", []):
            for change in entry.get("changes", []):
                value = change.get("value", {})
               
                # Procesar mensajes
                messages = value.get("messages", [])
                for message in messages:
                    messages_processed += 1
                    await process_single_message(message)
               
                # Procesar cambios de estado (opcional)
                statuses = value.get("statuses", [])
                if statuses:
                    logging.info(f"üìä Estados de mensaje recibidos: {len(statuses)}")
       
        # M√©tricas de performance
        processing_time = (datetime.now() - start_time).total_seconds()
        logging.info(f"‚ö° Webhook procesado ‚Üí {messages_processed} mensajes en {processing_time:.2f}s")
       
        return Response(status_code=200)
       
    except HTTPException:
        raise
    except Exception as e:
        processing_time = (datetime.now() - start_time).total_seconds()
        logging.error(f"üí• Error cr√≠tico procesando webhook (tiempo: {processing_time:.2f}s): {e}", exc_info=True)
        return Response(status_code=500, content="Internal server error")

async def process_single_message(message: Dict[str, Any]) -> None:
    """Procesador individual de mensajes con logging detallado"""
    try:
        from_msisdn = message.get("from")
        message_type = message.get("type")
        message_id = message.get("id", "unknown")
       
        # Log del mensaje recibido
        logging.info(f"üì± Nuevo mensaje ‚Üí ID: {message_id[:8]}... | Tipo: {message_type} | De: ****{from_msisdn[-4:] if from_msisdn else 'unknown'}")
       
        if message_type == "interactive":
            # Procesar mensajes interactivos (botones)
            interactive_data = message.get("interactive", {})
            await process_interactive_premium(from_msisdn, interactive_data)
           
        elif message_type == "text":
            # Procesar mensajes de texto
            text_data = message.get("text", {})
            message_text = text_data.get("body", "")
            await process_text_message_premium(from_msisdn, message_text)
           
        elif message_type in ["audio", "image", "document", "video", "sticker", "location", "contacts"]:
            # Manejo elegante de otros tipos de mensaje
            logging.info(f"üìé Mensaje multimedia recibido ‚Üí Tipo: {message_type}")
            await send_text(from_msisdn,
                f"üìé **Mensaje {message_type.title()} Recibido** ‚ú®\n\n"
                f"¬°Gracias por tu mensaje! Aunque recib√≠ tu {message_type}, "
                f"trabajo mejor con texto para brindarte respuestas precisas.\n\n"
                f"ü§ñ **¬øPrefieres usar el asistente virtual?**\n"
                f"Te ayudo a encontrar exactamente lo que necesitas üéØ")
            await asyncio.sleep(1)
            await send_welcome_experience(from_msisdn)
           
        else:
            # Tipo de mensaje no reconocido
            logging.warning(f"‚ö†Ô∏è Tipo de mensaje no manejado: {message_type}")
            await send_welcome_experience(from_msisdn)
           
    except Exception as e:
        logging.error(f"üí• Error procesando mensaje individual: {e}", exc_info=True)
        # Intentar enviar respuesta de error amigable
        try:
            if from_msisdn:
                await send_text(from_msisdn,
                    "üîß **Momento t√©cnico** ‚ö°\n\n"
                    "Disculpa, experiment√© un peque√±o problema t√©cnico. "
                    "¬°Pero ya estoy de vuelta! üòä\n\n"
                    "*¬øIntentamos de nuevo?*")
                await send_welcome_experience(from_msisdn)
        except:
            logging.error("üí• No se pudo enviar mensaje de error de recuperaci√≥n")

# ==================== ENDPOINTS DE MONITOREO Y ADMINISTRACI√ìN ====================

@app.get("/")
async def health_check_premium():
    """Health check con informaci√≥n detallada del sistema"""
    return {
        "status": "üöÄ ONLINE",
        "service": "Per Capital WhatsApp Bot Premium",
        "version": "3.0.0",
        "timestamp": datetime.now().isoformat(),
        "features": {
            "categories": len(QA_CATEGORIZED),
            "total_questions": sum(len(qa) for qa in QA_CATEGORIZED.values()),
            "active_conversations": len(conversation_state),
            "premium_features": True
        },
        "performance": {
            "message_processing": "Optimized with async/await",
            "error_handling": "Advanced with retry logic",
            "user_experience": "Premium with dynamic content"
        }
    }

@app.get("/dashboard")
async def admin_dashboard():
    """Dashboard administrativo con m√©tricas avanzadas"""
    total_questions = sum(len(qa) for qa in QA_CATEGORIZED.values())
   
    # Estad√≠sticas por categor√≠a
    category_stats = {}
    for category, questions in QA_CATEGORIZED.items():
        category_stats[category] = {
            "questions_count": len(questions),
            "percentage": round((len(questions) / total_questions) * 100, 1)
        }
   
    # Estad√≠sticas de conversaciones activas
    active_conversations = []
    for user, state in conversation_state.items():
        active_conversations.append({
            "user": f"****{user[-4:]}",
            "category": state.get("category", "N/A"),
            "timestamp": state.get("timestamp", "N/A"),
            "questions_viewed": len(state.get("questions_viewed", []))
        })
   
    return {
        "üéØ Bot Status": "PREMIUM ONLINE",
        "üìä Knowledge Base": {
            "total_categories": len(QA_CATEGORIZED),
            "total_questions": total_questions,
            "category_breakdown": category_stats
        },
        "üí¨ Active Conversations": {
            "count": len(conversation_state),
            "details": active_conversations
        },
        "üîß System Health": {
            "environment_vars": {
                "VERIFY_TOKEN": "‚úÖ" if VERIFY_TOKEN else "‚ùå",
                "WHATSAPP_TOKEN": "‚úÖ" if WHATSAPP_TOKEN else "‚ùå",
                "PHONE_NUMBER_ID": "‚úÖ" if PHONE_NUMBER_ID else "‚ùå",
                "APP_SECRET": "‚úÖ" if APP_SECRET else "‚ùå"
            },
            "api_version": GRAPH_API_VERSION
        }
    }

@app.post("/admin/broadcast")
async def send_broadcast_message(request: Request):
    """Endpoint para env√≠o masivo de mensajes (uso administrativo)"""
    try:
        data = await request.json()
        message_text = data.get("message", "")
        target_users = data.get("users", [])
       
        if not message_text or not target_users:
            raise HTTPException(status_code=400, detail="Message and users list required")
       
        # Env√≠o con control de rate limiting
        sent_count = 0
        failed_count = 0
       
        for user in target_users:
            try:
                await send_text(user, f"üì¢ **MENSAJE OFICIAL PER CAPITAL**\n\n{message_text}")
                sent_count += 1
                await asyncio.sleep(0.1)  # Rate limiting b√°sico
            except:
                failed_count += 1
       
        return {
            "status": "Broadcast completed",
            "sent": sent_count,
            "failed": failed_count,
            "total": len(target_users)
        }
       
    except Exception as e:
        logging.error(f"üí• Error en broadcast: {e}")
        raise HTTPException(status_code=500, detail="Broadcast failed")

@app.delete("/admin/conversations")
async def clear_all_conversations():
    """Limpia todas las conversaciones activas"""
    global conversation_state
    count = len(conversation_state)
    conversation_state.clear()
   
    logging.info(f"üßπ Admin: Limpieza masiva de {count} conversaciones")
   
    return {
        "status": "success",
        "action": "conversations_cleared",
        "count": count,
        "timestamp": datetime.now().isoformat()
    }

@app.get("/admin/conversations/{user_id}")
async def get_user_conversation(user_id: str):
    """Obtiene el estado de conversaci√≥n de un usuario espec√≠fico"""
    user_state = conversation_state.get(user_id)
   
    if not user_state:
        return {"status": "no_active_conversation", "user": user_id}
   
    return {
        "user": user_id,
        "state": user_state,
        "active": True
    }

# ==================== MANEJO GLOBAL DE ERRORES ====================

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Manejo elegante de errores HTTP"""
    logging.error(f"üö´ HTTP Error {exc.status_code}: {exc.detail}")
    return Response(
        status_code=exc.status_code,
        content=json.dumps({
            "error": f"HTTP {exc.status_code}",
            "message": exc.detail,
            "timestamp": datetime.now().isoformat()
        }),
        media_type="application/json"
    )

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Manejo global de excepciones con logging detallado"""
    logging.error(f"üí• Excepci√≥n global no manejada: {exc}", exc_info=True)
   
    return Response(
        status_code=500,
        content=json.dumps({
            "error": "Internal Server Error",
            "message": "Se produjo un error inesperado. El equipo t√©cnico ha sido notificado.",
            "timestamp": datetime.now().isoformat(),
            "support": "Contacta a soporte si el problema persiste"
        }),
        media_type="application/json"
    )

# ==================== STARTUP Y CONFIGURACI√ìN ====================

@app.on_event("startup")
async def startup_event():
    """Configuraci√≥n al inicio del servidor"""
    logging.info("üöÄ =" * 50)
    logging.info("üöÄ PER CAPITAL WHATSAPP BOT PREMIUM v3.0")
    logging.info("üöÄ =" * 50)
    logging.info(f"üìä Base de conocimiento cargada:")
   
    total_questions = 0
    for category, questions in QA_CATEGORIZED.items():
        questions_count = len(questions)
        total_questions += questions_count
        logging.info(f"   ‚Ä¢ {category}: {questions_count} preguntas")
   
    logging.info(f"‚úÖ Total: {len(QA_CATEGORIZED)} categor√≠as, {total_questions} preguntas")
    logging.info(f"üîß API Version: {GRAPH_API_VERSION}")
    logging.info(f"üèÉ‚Äç‚ôÇÔ∏è Bot PREMIUM listo para recibir mensajes!")
    logging.info("üöÄ =" * 50)

@app.on_event("shutdown")
async def shutdown_event():
    """Limpieza al cerrar el servidor"""
    logging.info("üõë Cerrando Bot Premium...")
    logging.info(f"üìä Conversaciones activas al cierre: {len(conversation_state)}")
    conversation_state.clear()
    logging.info("‚úÖ Bot cerrado correctamente")

# ==================== CONFIGURACI√ìN PARA DESARROLLO ====================

if __name__ == "__main__":
    import uvicorn
   
    print("üöÄ " + "=" * 60)
    print("üöÄ INICIANDO PER CAPITAL WHATSAPP BOT PREMIUM")
    print("üöÄ " + "=" * 60)
    print(f"üìä Categor√≠as: {len(QA_CATEGORIZED)}")
    print(f"üìù Preguntas totales: {sum(len(qa) for qa in QA_CATEGORIZED.values())}")
    print("üé® Caracter√≠sticas premium activadas")
    print("‚ö° Experiencia de usuario ultra optimizada")
    print("üîê Seguridad y validaciones avanzadas")
    print("üì± Listo para WhatsApp Cloud API")
    print("üöÄ " + "=" * 60)
   
    # Ejecutar servidor de desarrollo
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )